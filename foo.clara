::foreigntype JsString = _ ::methods {
  length: Int
}

::foreigntype JsString = {

}

---

::type JsString = _

::methods JsString = {
  length: Int
}

::foreignvalue JsString = {
  fromInt: (c: Int) => JsString
}

/*

//// native.d.clara
::type String = _
::type Int = _

::methods String {
  length: Int
}

::methods Int {
  plus: Int => Int
}

//// native.js

//// input.clara
someNumber = 1_000
foo = 'asd'
foo.length().plus someNumber

*/
/*
someNumber = 1_000
foo = 'asd'
foo.bar
foo . bar
*/


/*

real methods:
native types

fake methods:
wrapper types (newtype / AnyVal)

no methods:
structural types?

*/

newtype dimensions: isDeclared * shape

  - declared type
    - methods must be decl only
    - aka foreign

  - shape
    0     empty   ()
    1     value   Foo or (Foo)
    many  tuple   (A, B)
    many  object  {a: A, b: B}

          variant A |Â B


alias is just a plain alias on any type


-----


`f x` means
1) if there's a function value named f in scope -> call f with x
2) else if there's value f in scope with member (property or method) `apply` -> call f.apply with x
3) else if there's type f -> construct new f from x
