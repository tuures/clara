// using various language features to test they work end-to-end

// TODO: add warnings for unused constants

//////
// Block definitions

::opaque Float
::opaque Int
::opaque String

//@[emitName true]
::singleton True
//@[emitName false]
::singleton False

::alias Boolean: True | False

::alias Top: *
::alias Bottom: !
::alias Unit: ()

::tagged Player: {name: String, score: Int}
::tagged FooTagged<T>: T

::boxed FooId: String
::boxed BarId: String

//////
// Basic literals

float1: Float = 1.0
int1: Int = 1
int1000 = 1_000

string1: String = '1'
//string10 = "$(string1)0"
verbatimString = '$NoInterpolatio\n here'
difficultString = #''\t''# // literally '\t'

//////
// Records, Tuples

xyRecord: {x: Float, y: Float} = {x = 1.0, y = 0.5}
xyzRecord = {
  x = float1
  y = 0.5
  z = 0
}

// FIXME: add support for record shorthands both in valueexpr and patterns:
//makeTwo = <A>(first: A, second: A) => {first, second}

xyTuple: (Float, Float) = (1.0, 0.5)

//////
// Functions

identityFunc = <A>(a: A) => a
// FIXME:
// identityFunc2: (<A>A => A) = <A>(a: A) => a
constant1 = () => 1
first = <A, B>(a: A, _: B) => a
one = first(1,2)

//////
// Pattern matching
yesOrNo = #(
  True => 'yes'
  False => 'no'
)

yesNo = (yesOrNo True, yesOrNo False)

player1 = Player {name = "Player 1", score = 9000}

::alias FooBar: FooId | BarId
fooId: FooBar = FooId "xyz"
barId: FooBar = BarId "xyz"

fooTagged: FooTagged<Int> = FooTagged 1


higherOrderFunc = (f: String => String) => f("Bar")
higherOrderFunc(s => s)

// FIXME CallPattern
// isFooOrBar = #(
//   FooId _ => "Foo"
//   BarId _ => "Bar"
// )

//(isFooOrBar(fooId), isFooOrBar(barId))


//////
// Methods, Member selection, Pipe

// ::tagged True: ()
// True: True = True ()
// ::tagged False: ()
// False: False = False ()
// ::alias Boolean: True | False

// ::declare ::methods Float: {
//   @[emitKind binaryOperator] @[emitName +]
//   plus: Float => Float

//   @[emitKind binaryOperator] @[emitName -]
//   minus: Float => Float

//   @[emitKind binaryOperator] @[emitName *]
//   multiply: Float => Float

//   @[emitKind binaryOperator] @[emitName /]
//   divideBy: Float => Float
// }

// ::declare ::methods Int: {
//   @[emitKind binaryOperator] @[emitName +]
//   plus: Int => Int

//   @[emitKind binaryOperator] @[emitName -]
//   minus: Int => Int

//   @[emitKind binaryOperator] @[emitName *]
//   multiply: Int => Int

//   @[emitKind binaryOperator] @[emitName /]
//   divideBy: Int => Float
// }

// ::declare ::methods String: {
//   @[emitKind instanceProperty]
//   length: Int
// }

// ::declare ::type BrowserConsole = {
//   log: String => ()
// }

// ::declare ::val console: BrowserConsole

// foo = 1 .plus 2 .multiply 4_000

// bar = "asd".length.plus(1)

// zot = 1 .divideBy 2

// console.log("Hello World!")


// ::methods Maybe {
//   map<B>: Maybe<B> = (f: A => B) => this ??
//     | None => None
//     | Some(value) => f(value)
// }

()
