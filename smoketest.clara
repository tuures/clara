// using various language features to test they work end-to-end

::declare ::type Float: Any

::declare ::type Int: Any

::declare ::type String: Any

::declare ::type Boolean: Any
::declare true: Boolean
::declare false: Boolean

// ::tagged True: ()
// True: True = True ()
// ::tagged False: ()
// False: False = False ()
// ::alias Boolean: True | False

::declare ::methods Float: {
  @[emitKind binaryOperator] @[emitName +]
  plus: Float => Float

  @[emitKind binaryOperator] @[emitName -]
  minus: Float => Float

  @[emitKind binaryOperator] @[emitName *]
  multiply: Float => Float

  @[emitKind binaryOperator] @[emitName /]
  divideBy: Float => Float
}

::declare ::methods Int: {
  @[emitKind binaryOperator] @[emitName +]
  plus: Int => Int

  @[emitKind binaryOperator] @[emitName -]
  minus: Int => Int

  @[emitKind binaryOperator] @[emitName *]
  multiply: Int => Int

  @[emitKind binaryOperator] @[emitName /]
  divideBy: Int => Float
}

::declare ::methods String: {
  @[emitKind instanceProperty]
  length: Int
}

// ::declare ::type BrowserConsole = {
//   log: String => ()
// }

// ::declare ::val console: BrowserConsole

// foo = 1 .plus 2 .multiply 4_000

// bar = "asd".length.plus(1)

// zot = 1 .divideBy 2

// console.log("Hello World!")


// ::methods Maybe {
//   map<B>: Maybe<B> = (f: A => B) => this ??
//     | None => None
//     | Some(value) => f(value)
// }


// boxedInt = ::new Box { x = 1 }
// boxedInt.get


()
